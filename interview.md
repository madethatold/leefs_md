# 面向对象

实例化一个子类，java程序的执行顺序是：

父类对象属性初始化---->父类对象构造方法---->子类对象属性初始化--->子类对象构造方法

super在对象的内部使用，可以代表父类对象。

- 访问父类的属性：super.age

- 访问父类的方法：super.eat()



多态是面向对象编程语言的重要特性，它允**许基类的指针或引用指向派生类的对象**，而在具体访问时实现方法的动态绑定。

父类的引用可以指向本类的对象；

父类的引用可以指向子类的对象；

创建本类对象时，调用的方法为本类方法；

创建子类对象时，调用的方法为子类重写的方法或者继承的方法；

继承是多态的基础。

派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。 



就以上述的父类Animal和一个子类Dog来说明，当父类的引用可以指向子类的对象时，就是向上类型转换。

向下类型转换（强制类型转换），是大类型转换到小类型，有风险，可能会出现数据溢出。

Instanceof运算符**，**来解决引用对象的类型，避免类型转换的安全性问题。





Java为每种基本数据类型都提供了对应的包装器类型

自动装箱：Integer i = 10;将基本数据类型自动转换为对应的对象。

自动拆箱：Integer i = 10;  //装箱nt n = i;   //拆箱   动将包装器类型转换为基本数据类型

装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法

|  int（4字节）   |  Integer  |
| :-------------: | :-------: |
|  byte（1字节）  |   Byte    |
| short（2字节）  |   Short   |
|  long（8字节）  |   Long    |
| float（4字节）  |   Float   |
| double（8字节） |  Double   |
|  char（2字节）  | Character |
| boolean（未定） |  Boolean  |





- final 修饰类，则该类不允许被继承。

- final 修饰方法，则该方法不允许被覆盖(重写)。这样做的原因是方法已经实现好，不希望被子类重写覆盖。

- final 修饰属性，则该类的该属性不会进行隐式的初始化，所以 该final 属性的**初始化属性必须有值**，或在构造方法中赋值(但只能选其一，且必须选其一，因为没有默认值！)，且初始化之后就不能改了，只能赋值一次。

- final 修饰变量，则该变量的值只能赋一次值，在声明变量的时候才能赋值，即变为常量。

- final修饰的引用变量，引用不可更改，但引用的对象中的内容可以更改





​	**实例化一个对象主要由类的加载过程和对象的创建过程两部分组成。**

### **类的加载过程**

​	**首先，Jvm在执行时，遇到一个新的类时，会到内存中的方法区去找class的信息，如果找到就直接拿来用，如果没有找到，就会去将类文件加载到方法区。在类加载时，静态成员变量加载到方法区的静态区域，非静态成员变量加载到方法区的非静态区域。**

​	**静态代码块是在类加载时自动执行的代码，非静态代码块是在创建对象时自动执行的代码，不创建对象不执行该类的非静态代码块。**

**其具体过程如下：**

1. **JVM会先去方法区中找有没有相应类的.class存在。如果有，就直接使用；如果没有，则把相关类的.clss加载到方法区。**

2. **在.class加载到方法区时，先加载父类再加载子类；先加载静态内容，再加载非静态内容（如果父类和子类都有静态内容和非静态内容，架子啊顺序为：加载父类静态内容 -> 子类静态内容 -> 父类非静态内容 -> 子类非静态内容）**

3. **加载静态内容：**

- **把.class中的所有静态内容加载到方法区下的静态区域内**
- **静态内容加载完成之后，对所有的静态变量进行默认初始化**
- **所有的静态变量默认初始化完成之后，再进行显式初始化**
- **当静态区域下的所有静态变量显式初始化完后，执行静态代码块**

4. **加载非静态内容：把.class中的所有非静态变量及非静态代码块加载到方法区下的非静态区域内。至此，整个类的加载过程完毕。**

​	**额外注意：对于静态方法和非静态方法都是被动调用，即系统不会自动调用执行，所以用户没有调用时都不执行，主要区别在于静态方法可以直接用类名直接调用（实例化对象也可以），而非静态方法只能先实例化对象后才能调用。**

### **对象的创建过程**

1. **在堆中为新生对象分配内存；**

2. **调用构造函数初始化对象，构造函数分为隐式三步和显式一步：**
   1. **执行super()语句（隐式三步）**
   2. **对开辟空间下的所有非静态成员变量进行显示初始化（隐式三步）**
   3. **执行构造代码块（隐式三步）**
   4. **执行构造函数（显式一步）**

3. **初始化完毕后，将空间分配的地址赋给引用对象。**

**注：  执行构造函数可能出现以下三种情况:**

1. **构造方法体的第一行是this()语句，则不会执行隐式三步，而是调用this()语句所对应的的构造方法，最终肯定会有第一行不是this语句的构造方法。**

   ```java
   public class Student {
       private String name;
       private String age;
       Student() {}
       Student(String name) {
           // 会执行隐式三步
           this.name = name;
       }
       Student(String name, String age) {
           // 不会执行隐式三步
           this(name);
           this.age = age;
       }
   ```

   

2. **构造方法体的第一行是super()语句，则调用相应的父类的构造方法，** 

3. **构造方法体的第一行既不是this()语句也不是super()语句，则隐式调用super()，即其父类的默认构造方法，这也是为什么一个父类通常要提供默认构造方法的原因。**





抽象类与接口

abstract关键字修饰，则该类为抽象类。

抽象类是约束子类必须有什么方法，而并不关注子类如何实现这些方法。

- 子类必须实现抽象类中的抽象方法。

- 抽象类不能直接创建，可以定义引用变量来指向子类对象。